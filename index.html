<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D 4-op-een-rij</title>
  <style> body { margin: 0; overflow: hidden; } </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, controls;
    const size = 7;
    const spacing = 2;
    let board = Array.from({ length: size }, () => Array.from({ length: size }, () => Array(size).fill(null)));
    let currentPlayer = 'X';
    let cubes = [];

    init();
    buildBoard();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(15, 15, 30);

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      const light = new THREE.AmbientLight(0xffffff);
      scene.add(light);

      animate();
    }

    function buildBoard() {
      cubes = [];
      for (let z = 0; z < size; z++) {
        for (let x = 0; x < size; x++) {
          for (let y = 0; y < size; y++) {
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.2 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x * spacing, y * spacing, z * spacing);
            cube.userData = { x, z };
            scene.add(cube);
            cubes.push(cube);
          }
        }
      }
      window.addEventListener('click', handleClick);
    }

    function handleClick(event) {
      const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cubes);

      if (intersects.length > 0) {
        const { x, z } = intersects[0].object.userData;
        const y = getLowestY(x, z);
        if (y !== -1) {
          board[x][y][z] = currentPlayer;
          placePiece(x, y, z, currentPlayer);
          currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        }
      }
    }

    function getLowestY(x, z) {
      for (let y = 0; y < size; y++) {
        if (board[x][y][z] === null) {
          return y;
        }
      }
      return -1;
    }

    function placePiece(x, y, z, player) {
      const color = player === 'X' ? 0xff0000 : 0x0000ff;
      const sphereGeo = new THREE.SphereGeometry(0.7, 16, 16);
      const sphereMat = new THREE.MeshBasicMaterial({ color });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.set(x * spacing, y * spacing, z * spacing);
      scene.add(sphere);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>

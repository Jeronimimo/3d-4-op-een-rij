<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D 4-in-a-Row - 7x7x7</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #resetButton { position: absolute; top: 10px; left: 10px; z-index: 1; padding: 10px; background: white; }
  </style>
</head>
<body>
  <button id="resetButton">Restart Game</button>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const size = 7;
    const board = Array.from({ length: size }, () =>
      Array.from({ length: size }, () =>
        Array(size).fill(null)
      )
    );

    let scene, camera, renderer, controls;
    let currentPlayer = 'X';
    const spheres = [];

    init();
    renderBoard();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(20, 20, 40);

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      const light = new THREE.AmbientLight(0xffffff);
      scene.add(light);

      animate();
    }

    function renderBoard() {
      clearScene();
      spheres.length = 0;

      const spacing = 2;
      for (let z = 0; z < size; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshBasicMaterial({ color: 0xcccccc, opacity: 0.2, transparent: true });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x * spacing, y * spacing, z * spacing);
            cube.userData = { x, y, z };
            scene.add(cube);
            spheres.push(cube);

            if (board[x][y][z] !== null) {
              placeSphere(x, y, z, board[x][y][z]);
            }
          }
        }
      }

      window.addEventListener('click', onBoardClick);
    }

    function clearScene() {
      while (scene.children.length > 0) {
        scene.remove(scene.children[0]);
      }
    }

    function onBoardClick(event) {
      const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
      );
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(spheres);
      if (intersects.length > 0) {
        const { x, z } = intersects[0].object.userData;
        const y = findLowestEmptyY(x, z);
        if (y !== -1) {
          board[x][y][z] = currentPlayer;
          placeSphere(x, y, z, currentPlayer);

          if (checkWin(x, y, z, currentPlayer)) {
            alert(`Player ${currentPlayer} wins!`);
            window.removeEventListener('click', onBoardClick);
          } else if (isBoardFull()) {
            alert('Draw!');
            window.removeEventListener('click', onBoardClick);
          } else {
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
          }
        }
      }
    }

    function findLowestEmptyY(x, z) {
      for (let y = 0; y < size; y++) {
        if (board[x][y][z] === null) {
          return y;
        }
      }
      return -1;
    }

    function placeSphere(x, y, z, player) {
      const color = player === 'X' ? 0xff0000 : 0x0000ff;
      const sphereGeo = new THREE.SphereGeometry(0.7, 16, 16);
      const sphereMat = new THREE.MeshBasicMaterial({ color });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.set(x * 2, y * 2, z * 2);
      scene.add(sphere);
    }

    function checkWin(x, y, z, player) {
      const directions = [
        [1, 0, 0], [0, 1, 0], [0, 0, 1],
        [1, 1, 0], [1, 0, 1], [0, 1, 1],
        [1, 1, 1], [1, -1, 0], [1, 0, -1],
        [0, 1, -1], [1, -1, -1], [-1, 1, 1]
      ];

      for (const [dx, dy, dz] of directions) {
        let count = 1;
        count += countDirection(x, y, z, dx, dy, dz, player);
        count += countDirection(x, y, z, -dx, -dy, -dz, player);
        if (count >= 4) return true;
      }
      return false;
    }

    function countDirection(x, y, z, dx, dy, dz, player) {
      let count = 0;
      let nx = x + dx;
      let ny = y + dy;
      let nz = z + dz;

      while (nx >= 0 && nx < size && ny >= 0 && ny < size && nz >= 0 && nz < size && board[nx][ny][nz] === player) {
        count++;
        nx += dx;
        ny += dy;
        nz += dz;
      }
      return count;
    }

    function isBoardFull() {
      for (let x = 0; x < size; x++) {
        for (let y = 0; y < size; y++) {
          for (let z = 0; z < size; z++) {
            if (board[x][y][z] === null) return false;
          }
        }
      }
      return true;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    document.getElementById('resetButton').addEventListener('click', () => {
      for (let x = 0; x < size; x++) {
        for (let y = 0; y < size; y++) {
          for (let z = 0; z < size; z++) {
            board[x][y][z] = null;
          }
        }
      }
      currentPlayer = 'X';
      renderBoard();
    });
  </script>
</body>
</html>
